{"type":"post","name":"BetterCstdio: The library that will change how you program","image":"wp2234590jpg","content":"This library adds simple implimentations that improve the \"quality of life\" in programming. By adding features such as mutable/dynamic strings, you no longer have to sacrifice qualities found in other slower programming languages. By adding this library, you will have access to the following:\r\n- Mutable/Dynamic Strings\r\n- Easy Linked Lists\r\n\r\n## Motivation for Creation\r\n\r\nOver time, more will be added to this library. C is my best language as well as my prefered one. The only drawback in using C is the lack of many simple features found in other languages. Due to this, I decided to add common functionalities needed in most programs.\r\n\r\n## Examples & Documentation\r\n### Mutable/Dynamic Strings\r\nNowadays, it is very uncommon to find a language that does not have Mutable or dynamically allocated strings. In this library, strings are implemented with basic object-oriented programming features. In C, object-oriented programming is made possible with the use of function pointers. Though, it does come with a few drawbacks. \r\nThe first drawback is the required initializer function. This function must be called upon creation of the struct as without it, the function pointers will not be pointing to anything. The standard initialization of a string is shown below.\r\n```\r\n// Without a string\r\nstring newstring = initString(\"\");\r\n// With a string\r\nstring newstring = initString(\"This string has been initialized!\");\r\n```\r\n\r\nThe second drawback is a requirement of a self argument. With the use of function pointers, you are basically just creating an alias of the normal function. Due to this, you will still need to supply the address of the struct as you normally would with the function that is being pointed to.\r\n```\r\n// The self pointer is just the address of the string.\r\nnewstring.print(&newstring);\r\n```\r\n\r\nNow, after understanding these drawbacks, we can move on to understanding how to use the pre-created functions. Firstly, the most simple function is **print**. This function will print out the string along with a trailing newline. The example usage of the function is shown below.\r\n```\r\nnewstring.print(&newstring);\r\n```\r\n\r\nFollowing print, there is also an **input** function that dynamically allocated the input. Realloc is not intended to be used in an iterative manner as it is constantly searching for free memory spaces. Due to this, a blocksize argument is used to allow for more efficient allocation. For example, if you know that you will be allocating over one kilobyte of data, a block size of one kilobyte is an efficient choice. This blocksize will reallocate an extra kilobyte when needed. An example of this is shown below.\r\n```\r\n// This takes user input with a block size of one kilobyte\r\nnewstring.input(&newstring, 1024);\r\n```\r\n\r\n**find** is another function that, as described by the name, will return the position of the first matching substring. For example, if the string is \"This is a test\" and the selector is \"test\", the returned integer will be 10.\r\n```\r\nnewstring.find(&newstring, \"test\");\r\n```\r\n\r\nNext, we have **length** which is also pretty self-explanatory. This function returns the length of the string itself by iterating through the string until a null byte is found. An example of this function is shown below.\r\n```\r\nnewstring.length(&newstring);\r\n```\r\n\r\nThe ability to append is also included in this library through the function **append**. As described by the name, this function will append/concatenate two strings together. If the string's initial value is \"first\", by concatenating \" second\", the result will be \"first second\". An example is shown below.\r\n```\r\nnewstring.append(&newstring, \" second\");\r\n```\r\n\r\nPaired with these functions, you also have the **substr** function. This function takes two position arguments in the form of integers. The first integer is the start position of the substring and the second is the end position. An example is shown below.\r\n```\r\n// This is taking a substring from the string \"this is a test\"\r\nnewstring.substr(&newstring, 10, 14);\r\n// This will output \"test\"\r\n```\r\n\r\nLastly, you have **replace**. This function takes in two strings. The first string is the value that will be found and replaced. The second value is the replacement.\r\n```\r\n// Using the string \"The word temp will be replaced\",\r\nnewstring.replace(&newstring, \"temp\", \"replaced\");\r\n// The result will be \"The word replaced will be replaced\"\r\n```","_id":"qfrff3ICbjCJoc5N"}
